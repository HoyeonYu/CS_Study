# Software Design (소프트웨어 설계)

## Contents  
[**1. 요구사항 확인**](#1-요구사항-확인)  
[**2. 화면 설계**](#2-화면-설계)  
[**3. 어플리케이션 설계**](#3-어플리케이션-설계)  
[**4. 인터페이스 설계**](#4-인터페이스-설계)  

----

## 1. 요구사항 확인  
1. 소프트웨어 생명주기
	- 소프트웨어를 개발하기 위한 과정을 각 단계별로 나눈 것
	- 소프트웨어 생명 주기 모형
		- Waterfall Model (폭포수 모형)  
			![image](https://user-images.githubusercontent.com/53277342/153363657-db248743-2bb2-40bf-b7ce-c5f6c60bdcf6.png)
			- 각 단계를 확실히 매듭짓고 다음 단계를 진행하는 개발 방법론
			- 선형 순차적 모형
			- 고전적 생명 주기 모형
			
		- Prototype Model (프로토타입 모형)  
			![image](https://user-images.githubusercontent.com/53277342/153363804-4ad3fba7-6baa-44e2-8858-2736cdd56d56.png)
			- 실제 개발될 소프트웨어에 대한 견본(프로토타입)을 만들어 최종 결과물 예측
		
		- Spiral Model (나선형 모형, 점진적 모형)  
			![image](https://user-images.githubusercontent.com/53277342/153364058-a9138cef-7e66-491d-b9f4-aa2d2b11c067.png)
			- 폭포수 모형 + 프로토타입 모형 + 위험 분석 기능
			- 여러 번의 개발 과정을 거쳐 점진적으로 완벽한 소프트웨어 개발
			- 유지보수 과정 필요 없음
			- 위험 관리, 위험 최소화 목적
		
		- Agile Model (애자일 모형)  
			- 일정한 주기(Sprint, Iteration)를 반복하면서 개발과정 진행
			- 고객과의 소통에 초점을 맞춘 방법론
			- 급변하는 요구사항에 적합
			- ex) Scrum, XP, Kanban, ASD, FDD(Feature Driven Development, 기능중심개발)

2. Scrum 기법
	- 럭비에서 서로 대치해있는 대형 의미, 팀이 중심이 되어 개발의 효율성 높임
	- 팀 구성
		- PO (Product Owner, 제품 책임자)  
			- 요구사항 작성 주체, 주로 개발 의뢰자나 사용자가 담당
			- Backlog 작성, 우선순위 지정
			- 주기적으로 요구사항 우선순위 갱신
		- SM (Scrum Master, 스크럼 마스터)  
			- 스크럼을 잘 수행할 수 있도록 조언해주는 가이드 역할
			- 일일 스크럼 회의 주관, 진행사항 점검, 장애요소 공론화 및 처리
		- DT (Development Team, 개발팀)   
			- PO와 SM을 제외한 모든 팀원
			- 개발자 외에도 개발에 참여하는 모든 사람이 대상
	- 개발 프로세스
		1. Product Backlog (제품 백로그)  
			- 제품 개발에 필요한 모든 요구사항을 우선순위에 따라 나열한 목록
			- 지속적 업데이트
			- 릴리즈 계획 수립
		2. Sprint Planning Meeting (스프린트 계획 회의)  
			- 단기 일정 수립
			- 요구사항을 Task 작업 단위로 분할 후 Sprint Backlog 작성
		3. Sprint
			- 실제 개발 작업 진행
			- To Do(할 일), In Progress(진행 중), Done(완료)의 상태 가짐
			- Daily Scrum Meeting (일일 스크럼 회의)
				- 매일 15분정도의 짧은 시간동안 진행상황 점검
				- 남은 작업 시간 Burn-down Chart(소멸차트)에 표시
		4. Sprint Review (스프린트 검토 회의)
			- 요구사항에 잘 부합되는지 사용자 앞에서 테스팅 수행
			- PO는 개선할 사항에 대해 피드백 정리, Product Backlog 업데이트
		5. Sprint Retrospective (스프린트 회고)
			- 스프린트 주기 되돌아보며 규칙 잘 준수했는지, 개선할 점 확인 및 기록

3. XP(eXtreme Programming) 기법  
	- 고객의 참여와 개발과정의 반복 극대화해 개발 생산성 향상시키는 방법
		- 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적 참여
		- 소프트웨어를 빠르게 개발하는 것을 목적
	- 핵심 가치
		- Communication(의사소통)
		- Simplicity(단순성)
		- Courage(용기)
		- Respect(존중)
		- Feedback(피드백)
	- 개발 프로세스  
	![image](https://user-images.githubusercontent.com/53277342/153368805-a7142f73-e107-40c7-942e-3ee59caff769.png)
		1. User Story (사용자 스토리)
			- 고객의 요구사항을 간단한 시나리오로 표현
			- 기능 단위로 구성, 테스트 사항 기재
		2. Release Planning (릴리즈 계획 수립)
			- 릴리즈: 부분적으로 기능이 완료된 제품을 제공하는 것
		3. Spike (스파이크)
			- 신뢰성 향상, 위험 감소하기 위해 별도로 만든 간단한 프로그램
			- 처리할 문제 외의 조건은 모두 무시하고 작성
		4. Iteration (이터레이션)
			- 하나의 릴리즈를 더 세분화한 단위
			- 1~3주 정도의 기간으로 진행
			- 기간 중에 새로운 스토리 작성 가능
		5. Acceptation Test (승인 검사, 인수 테스트)
			- 릴리즈 단위 부분 완료 제품 구현되면 수행하는 테스트
			- 사용자 스토리 작성 시 기재한 테스트 사항에 대해 고객이 직접 수행
			- 발견한 오류 사항은 다음 이터레이션에 포함
			- 새로운 요구사항 작성, 상대적 우선순위 변경 가능
		6. Small Release (소규모 릴리즈)
			- 소규모의 경우 고객의 반응 기능별로 확인 가능, 요구사항 유연히 대응 가능
			- 이터레이션이 모두 완료되면 고객에 의한 최종 테스트 수행, 고객 전달
	- 주요 실천 방법
		- Pair Programming (짝 프로그래밍)
			- 개발에 대한 책임 공동 소유
		- Collective Ownership (공동 코드 소유)
			- 개발 코드에 관한 권한과 책임 공동 소유
		- Test-Driven Development (테스트 주도 개발)
			- 개발자가 테스트케이스 먼저 작성하여 무엇을 해야할지 정확히 파악
			- 자동화된 테스팅 도구 사용
		- Whole Team (전체 팀)
			- 모든 구성원들은 각자 자신의 역할을 가지며 역할에 대한 책임 가짐
		- Continous Integration (CI, 계속적인 통합)
			- 하나의 작업 마무리될 때마다 모듈 단위로 나눠 개발된 코드들 지속적 통합
		- Design Improvement (= Refactoring, 디자인개선)
			- 프로그램 기능 변경 없이 단순화, 유연성 강화 통해 시스템 재구성
		- Small Releases (소규모 릴리즈)
			- 릴리즈 기간 짧게 반복해 고객의 요구 변화에 신속히 대응

4. 현행 시스템 파악
	- 새로 개발하려는 시스템의 개발 범위 명확히 설정 목표
	- 파악 절차
		1. 1단계
			1. 시스템 구성 파악
				- 기간 업무, 지원 업무 구분하여 기술
					- 기간 업무: 조직의 주요 담당 업무
					- 지원 업무: 담당 업무를 지원하기 위한 업무
			2. 시스템 기능 파악
				- 단위 업무 시스템이 현재 제공하는 기능들을 주요기능 - 세부기능으로 구분
			3. 시스템 인터페이스 파악
				- 단위 업무 시스템간 주고받는 데이터 정보 명시
					- 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기
		2. 2단계
			1. 아키텍처 구성 파악
				- 기간 업무 수행에 어떤 기술 요소들 사용되는지 아키텍처 구성도 작성
			2. 소프트웨어 구성 파악
				- 단위 업무 시스템별로 설치되어 있는 소프트웨어의 정보 명시
					- 소프트웨어 제품명, 용도, 라이센스 적용 방식, 라이센스 수
		3. 3단계
			1. 하드웨어 구성 파악
				- 단위 업무 시스템들이 운용되는 서버의 정보 명시
					- 서버 주요 사양, 수량, 이중화 적용 여부
						- 이중화(Replication): 운용 서버의 장애 시 대기 서버
			2. 네트워크 구성 파악
				- 서버의 위치, 서버간 네트워크 연결 방식을 네트워크 구성도로 작성

5. 개발 기술 환경 파악
	- 개발 기술 환경: 개발하고자 하는 소프트웨어와 관련된 요소의 고려사항 기술
		- 관련 요소
			- OS (Operation System, 운영체제)
				- 컴퓨터 시스템의 자원 편리하고 효율적으로 사용하도록 환경 제공하는 소프트웨어
				- 컴퓨터 사용자와 하드웨어간의 인터페이스
				- ex) Windows, UNIX, Linux, Mac OS, iOS, Android
				- 고려사항
					- 가용성, 성능, 기술 지원, 주변 기기, 구축 비용
			- DBMS (DataBase Management System, 데이터베이스 관리시스템)
				- 사용자의 요구에 따라 정보 생성, DB 관리해주는 소프트웨어
				- 데이터의 종속성과 중복성 문제 해결하기 위해 제안된 시스템
				- 모든 응용 프로그램들이 DB 공용할 수 있도록 관리
				- DB 구성, 접근 방법, 유지관리에 대한 모든 책임 가짐
				- ex) Oracle, MySQL, SQLite, MongoDB, Redis
				- 고려사항
					- 가용성, 성능, 기술 지원, 상호 호환성, 구축 비용
			- WAS (Web Application Server, 웹 어플리케이션 서버)
				- 동적 컨텐츠를 처리하기 위해 사용되는 미들웨어
				- 데이터 접근, 세션 관리, 트랜잭션 관리 위한 라이브러리 제공
				- 주로 DB 서버와 연동해서 사용
				- ex) Tomcat, JEUS, WebSphere
				- 고려사항
					- 가용성, 성능, 기술 지원, 구축 비용
			- Open Source
				- 누구나 별다른 제한 없이 사용할 수 있도록 소스코드 공개한 것
				- 고려사항
					- 라이선스 종류, 사용자 수, 기술의 지속 가능성
			
6. 요구사항 정의
	- 요구사항: 서비스에 대한 설명, 정상적으로 운영되는데 필요한 제약조건
	- 유형
		- Functional Requirements (기능 요구사항)
			- 시스템이 무엇을 하는지, 어떤 기능을 하는지
			- 입출력에 무엇이 포함되어야 하는지
			- 어떤 데이터를 저장하거나 연산을 수행해야 하는지
		- Non-functional Requirements (비기능 요구사항)
			- 시스템 장비 구성, 서능, 인터페이스, 데이터, 테스트, 보안, 품질, 관리, 지원 요구사항
		- User Requirements (사용자 요구사항)
			- 사용자 관점에서 제공해야할 요구사항
			- 친숙한 표현 사용
		- System Requirements (시스템 요구사항, 소프트웨어 요구사항)
			- 개발자 관점에서 제공해야할 요구사항
			- 전문적이고 기술적인 용어 사용
	- 개발 프로세스
		1. Requirement Elicitation (요구사항 도출, 수집)
			- 요구사항이 어디에 있는지, 어떻게 수집할 것인지 식별 및 이해
			- 효율적인 의사소통 중요
			- 기법: 인터뷰, 브레인스토밍, 프로토타이핑, 유스케이스
			
		2. Requirement Analysis (요구사항 분석)
			- 요구사항 중 명확하지 않아 이해되지 않는 부분 발견, 걸러내기 위한 과정
			- 타당성 조사, 비용 및 일정에 대한 제약 설정
			- 상충되는 요구사항 중재
			- 소프트웨어 범위 파악
			- 구조적 분석 기법
				- 자료의 흐름과 처리 중심 요구사항 분석 방법
				- 도형 중심의 도구 사용해 대화 용이
				- 하향식 방법 사용해 시스템 세분화, 분석 중복 배제
				- ex) DFD, DD, Mini-Spec., ERD, STD, 제어 명세서
					- DFD (Data Flow Diagram, 자료 흐름도, 자료 흐름도, 버블 차트)
						- 자료의 흐름 및 변환 과정, 기능을 도형 중심으로 기술하는 방법
						- 기호  
							![image](https://user-images.githubusercontent.com/53277342/153383602-b6f1ca95-cfc9-4039-b530-648ef0f1d8e8.png)
							- Process(프로세스): 자료 변환시키는 부분
							- Data Flow(자료 흐름): 자료의 이동이나 연관관계
							- Data Store(자료 저장소): 시스템에서의 자료 저장소(파일, DB)
							- Terminator(단말): 시스템과 교신하는 외부 개체, 입력 데이터 생성, 출력 데이터 받음
					- DD (Data Dictionary, 자료 사전)
						- DFD에 있는 자료 더 자세히 정의, 기록
						- Meta Data: 데이터를 설명하는 데이터, 데이터의 데이터
						- 기호  
							![image](https://user-images.githubusercontent.com/53277342/153393935-6edd7c8e-472e-4e69-bdbb-6c87b1989b87.png)		
			- CASE
				- 요구사항 자동 분석, 분석 명세서를 기술하도록 개발된 도구
				- 문서화 품질 개선, 명세에 대한 유지보수 비용 축소, 영향 추적의 용이성
				- 종류
					- SADT(Structured Analysis and Design Technique)
						- 시스템 분석, 요구사항 분석, 시스템 설계 위한 구조적 분석 및 설계 도구
						- 블록 다이어그램 채택
					- SREM(Software Requirements Engineering Methodology, RSL/REVS)
						- 실시간 처리 소프트웨어에서 요구사항 명확히 기술 목적
						- RSL, REVS 사용
							- RSL(Requirement Statement Language)
								- 요소, 속성, 관계, 구조 기술하는 요구사항 기술 언어
									- 요소: 요구사항 명세 개발 위해 사용되는 개체, 개념
									- 속성: 요소 수정, 수식
									- 관계: 개체들간의 관계
									- 구조: 정보 흐름 묘사
							- REVS(Requirement Engineering and Validation System)
								- RSL로 기술된 요구사항 자동 분석, 요구사항 분석 명세서 출력
					- PSL/PSA
						- PSL과 PSA 사용하는 자동화 도구
							- PSL(Problem Statement Langauage)
								- 요구사항 기술 언어
							- PSA(Problem Statement Analyzer)
								- PSL로 기술된 요구사항 자동 분석, 요구사항 분석 명세서 출력
					- TAGS(Technology for Automated Generation of Systems)
						- 시스템공학 방법 응용에 대한 자동 접근 방법
						- 개발 주기의 전 과정에 이용 가능한 통합 자동화 도구
						- IORL: 요구사항 명세 언어

			- HIPO(Hierarchy Input Process Output)
				- 시스템 분석, 설계, 문서화할 떄 사용되는 기법
				- 입력, 처리, 출력 기능 나타냄
				- 하향식 소프트웨어 개발 위한 문서화 도구
				- HIPO Chart: 시스템 기능을 여러 개의 모듈로 분할하여 모듈간의 인터페이스를 계층 구조로 표현
					- Visual Table of Contents(가시적 도표, 도식 목차): 시스템의 전체적 기능, 흐름 보여주는 계층 구조도
					- Overview Diagram(총체적 도표, 개요 도표): 프로그램 구성 기능 기술, 입력-처리-출력에 대한 정보 제공
					- Detail Diagram(세부적 도표, 상세 도표): 총체적 도표에 표시된 기능을 구성하는 기본 요소들 상세 기술

		3. Requirement Specification (요구사항 명세)
			- 분석된 요구사항 바탕으로 모델 작성, 문서화
			- 기능 요구사항: 빠짐없이 완전하고 명확하게 기술
			- 비기능 요구사항: 필요한 것만 명확하게 기술
			- Software Requirement Specification (소프트웨어 요구사항 명세서)
				- 소프트웨어가 반드시 제공해야 하는 기능, 특징, 제약조건 명시
				- 명세 기법
					- 정형 명세 기법
						- 수학적 원리, 모델 기반
						- 수학적 기호로 정형화된 표기법 사용
						- ex) VDM, Z, CSP
					- 비정형 명세 기법
						- 상태, 기능, 객체 중심
						- 자연어 기반 서술, 다이어그램 작성
						- ex) FSM, ER 모델링, Decision Table, State Chart(SADT)
		4. Requirement Validation (요구사항 확인, 검증)
			- 요구사항 명세서가 정확하고 완전하게 작성되었는지 검토

7. UML(Unified Modeling Language)
	- 시스템 개발 과정에서 의사소통이 원할하도록 표준화한 객체지향 모델링 언어
	- 구성 요소
		- Things(사물)
			- 관계가 형성될 수 있는 대상
			- Structural Things(구조 사물)
				- 시스템의 개념적, 물리적 요소 표현
				- ex) Class, Use Case, Component, Node
			- Behavioral Things(행동 사물)
				- 시간과 공간에 따른 요소들의 행위 표현
				- ex) Interaction(상호작용), State Machine(상태 머신)
			- Grouping Things(그룹 사물)
				- 요소들 그룹으로 묶어서 표현
				- ex) Package
			- Annotation Things(주해 사물)
				- 부가 설명, 제약조건 표현
				- ex) Note

		- Relationships(관계)
			- 사물간의 연관성 표현  
			  ![image](https://user-images.githubusercontent.com/53277342/153404287-6ee6d406-e879-48bd-9f4f-83ad708cb7fa.png)
			- Association(연관 관계)
				- 2개 이상의 사물이 서로 관련된 관계
				- 양방향 관계의 경우 화살표 생략
				- Multiplicity(다중도) 선 위에 표기
			- Aggregation(집합 관계)
				- 하나의 사물(Part)이 다른 사물(Whole)에 포함되어있는 관계
				- Part와 Whole은 서로 독립적
				- Part에서 Whole 쪽으로 속이 빈 마름모 향함
			- Composition(포함 관계)
				- 집합 관계의 특수한 형태, Whole의 변화가 Part에 영향을 미치는 관계
			- Generalization(일반화 관계, 상속)
				- 하나의 사물(Parent)이 다른 사물(Child)에 비해 더 일반적인 관계
				- Child에서 Parent 쪽으로 속이 빈 화살표 향함
			- Dependency(의존 관계)
				- 서로 포함관계가 아니고 사물의 변화가 다른 사물에 영향 미치는 관계
				- 영향을 주는 사물에서 영향을 받는 사물 쪽으로 점선 화살표 향함
			- Realization(실체화 관계, 인터페이스)
				- 사물이 할 수 있거나 해야하는 기능으로 서로 그룹화할 수 있는 관계
				- 사물에서 기능 쪽으로 속이 빈 점선 화살표 향함

		- Diagram
			- 사물과 관계를 도형으로 표현한 것
			- 여러 관점에서 시스템을 가시화한 View 제공
			- Structural Diagram
				- 주로 정적 모델링에서 사용
				- Class Diagram: 클래스 사이의 관계 표현
					- 클래스: 이름, 속성, 오퍼레이션으로 표기
					- 제약조건: 입력될 값, 오퍼레이션 수행 전후에 지정할 조건 표기
					- 관계: 클래스간 연관성 표현
						- 연관, 집합, 포함, 일반화, 의존 관계
					- 접근 제어자
						- public(+): 어떤 클래스든 접근 가능
						- private(-): 해당 클래스 내부에서만 접근 가능
						- protected(#): 동일 패키지 내 클래스, 상속받은 외부 패키지 클래스에서 접근 가능
						- package(~): 동일 패키지 내 클래스만 접근 가능
				- Object Diagram: 특정 시점의 객체간 관계 표현
				- Component Diagram: 컴포넌트간 관계 표현
				- Deployment Diagram: 물리적 요소들의 위치 표현
				- Composite Structure Diagram: 복합 구조 갖는 경우 내부 구조 표현
				- Package Diagram: 패키지들의 관계 표현
				
			- Behavioral Diagram
				- Use Case Diagram: 사용자의 요구 분석 위해 수행할 수 있는 기능을 사용자의 관점에서 표현  
					![image](https://user-images.githubusercontent.com/53277342/153552631-cdc4e1a1-fc91-4cd3-8ebb-a90ab7ac2947.png)
					- System: 시스템 내부와 외부 구분 위해 시스템 내부를 사각형으로 묶어 범위 표현
					- Actor: 시스템과 상호작용하는 모든 외부 요소
						- 주액터(사용자 액터): 시스템을 사용해 이득을 얻는 대상, 주로 사람
						- 부액터(시스템 액터): 시스템에 서비스를 제공하는 외부 시스템, 조직이나 기관
					- Use Case: 시스템이 액터에게 제공하는 서비스 또는 기능
					- Relationship: Actor - Use Case, Use Case - Use Case 간 관계
						- Include: Use Case간 공통적으로 적용되는 기능을 별도로 분리해 새로운 Use Case 만든 경우
						- Extend: Use Case가 특정 조건에 부합돼 기능이 확장되는 관계
						- 연관관계
				- Sequence Diagram: 객체들이 주고받는 메시지 표현
					- Actor: 시스템으로부터 서비스 요청하는 외부 요소
					- Object(객체): 메시지 주고받는 주체
					- Lifeline(생명선): 객체가 메모리에 존재하는 기간
					- Active Box(실행 상자): 객체가 메시지 주고받으며 구동되고 있음 표현
					- Message: 객체가 상호작용을 위해 주고받는 메시지
				- Communication Diagram: 객체간 메시지 + 연관관계 표현
				- State Diagram: 속한 클래스의 상태 변화, 객체간 상호작용에 따른 변화 표현
				- Activity Diagram: 시스템의 처리 흐름을 순서에 따라 표현
				- Interation Overview Diagram: 상호작용 다이어그램간 제어흐름 표현
				- Timing Diagram: 객체 상태 변화, 시간 제약 명시적 표현
		
		- Stereotype
			- 기본 기능 외에 추가적 기능 표현
			- << >> (Guilemet, 길러멧) 사이에 표현할 형태 기술
				- include, extend, interface, exception, constructor

## 2. 화면 설계

1. UI (User Infterface, 사용자 인터페이스)
	- 사용자와 시스템간의 상호작용이 원할하도록 돕는 장치나 소프트웨어
	- 구분
		- CLI (Command Line Interface): 명령과 출력이 텍스트 형태로 이루어지는 인터페이스
		- GUI (Graphic User Interface): 마우스로 선택해 작업 수행하는 그래픽 환경 인터페이스
		- NUI (Natural User Interface): 사용자의 말이나 행동으로 조작하는 인터페이스
	- 기본 원칙
		- 직관성, 유효성, 학습성, 유연성
	- 설계 지침
		- 사용자 중심, 일관성, 단순성, 결과 예측 가능, 가시성, 표준화, 접근성, 명확성, 오류 발생 해결
	- 기능
		- 사용자의 입력 검증
		- 에러 처리 및 에러 메시지 표시
		- 도움과 프롬프트 제공

2. UI 설계 도구
	- 기획단계에서 미리 보여주기 위한 용도로 사용
	- 단계
		1. Wireframe: 기획단계 초기 제작, 개략적인 레이아웃, 뼈대 설계
		2. Mockup: Wireframe보다 더 실제와 유사하게 만든 정적 형태 모형
		3. Story Board: 디자이너와 개발자가 최종 참고하는 작업 지침서, 서비스 구축 위한 모든 Description 기입
		4. Prototype: Interaction 적용하여 테스트가 가능한 동적인 형태의 모형
		5. Use Case: 사용자 측면에서의 요구사항

3. 품질 요구사항
	- 소프트웨어 품질: 요구사항이 얼마나 충족하는가를 나타냄
	- 품질평가 표준 지침
		- ISO/IEC 9126: 품질 평가 위한 표준 지침
			- 기능성: 요구사항을 정확하게 만족하는 기능을 제공하는지
				- 적절성 / 적합성, 정밀성 / 정확성, 상호 운용성, 보안성, 준수성
			- 신뢰성: 요구된 기능을 오류 없이 수행할 수 있는지
				- 성숙성, 고장 허용성, 회복성
			- 사용성: 사용자가 쉽게 배우고 사용하며 다시 사용하고 싶은지
				- 이해성, 학습성, 운용성, 친밀성
			- 효율성: 한정된 자원으로 얼마나 빠르게 처리 가능한지
				- 시간 효율성, 자원 효율성
			- 유지 보수성: 환경 변화나 새로운 요구사항 발생 시 소프트웨어 개선이나 확장 가능한지
				- 분석성, 변경성, 안정성, 시험성
			- 이식성: 다른 환경에서 얼마나 쉽게 적용할 수 있는지
				- 적응성, 설치성, 대체성, 공존성
		- IS0/IEC 25010: ISO/IEC 9126 개정
		- ISO/IEC 12119: 테스트 절차 포함해 규정
		- ISO/IEC 14598: 필요 절차를 규정한 

4. UI 상세 설계
	- UI 설계서 바탕으로 자세한 설계 진행하는 단계
	- UI 시나리오 문서
		- 계층구조나 Flow Chart로 표기
		- UI 설계자, 인터랙션 디자이너가 작성, 후에 그래픽 디자이너가 디자인, 개발자가 UI 구현
		- 완전성, 일관성, 이해성, 가독성, 수정 용이성, 추적 용이성

## 3. 어플리케이션 설계
1. 소프트웨어 아키텍처
	- 소프트웨어를 구성하는 요소들 간 관계 표현하는 시스템의 구조
	- 설계 구분
		- 상위 설계: 아키텍처 설계, 예비 설계
		- 하위 설계: 모듈 설계, 상세 설계
	- 기본 원리
		- Modularity (모듈화)
			- 시스템의 기능들 모듈 단위로 나누는 것
			- 시스템 수정, 재사용, 유지 관리 용이 목적
		- Abstraction (추상화)
			- 전체적이고 포괄적 개념 설계한 후 차례로 세분화하여 구체화시켜 나감
			- 최소의 비용으로 실제 상황 대처, 시스템 구조 및 구성 대략적 파악 가능
			- 유형
				- 과정 추상화: 자세한 수행 과정 정의 X, 전반적인 흐름만 파악할 수 있게 설계
				- 데이터 추상화: 데이터의 세부적 속성이나 용도 정의 X, 데이터 구조 대표할 수 있는 표현으로 대체
				- 제어 추상화: 이벤트 발생 절차나 방법 정의 X, 대표할 수 있는 표현으로 대체
		- Stepwise Refinement (단계적 분해)
			- 문제를 상위 개념으로부터 하위 개념으로 구체화
			- 추상화의 반복에 의해 세분화
		- Information Hiding (정보 은닉)
			- 한 모듈 내 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 함
			- 커뮤니케이션할 필요가 있을 때는 필요한 정보만 인터페이스 통해 주고 받음
			- 모듈 독립적 수행, 수정 유지보수 용이 목적
	- 품질 속성
		- 품질 평가 요소들 구체화
		- 측면
			- 시스템 측면
				- 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성
			- 비즈니스 측면
				- 시장 적시성, 비용과 혜택, 예상 시스템 수명, 목표 시장
			- 아키텍처 측면
				- 개념적 무결성, 정확성, 완결성, 구축 가능성, 변경성, 적응성
	- 설계 과정
		1. 설계 목표 설정
		2. 시스템 타입 결정
		3. 아키텍처 패턴 적용
		4. 서브시스템 구체화
		5. 검토

2. 아키텍처 패턴
	- 아키텍처를 설계할 떄 참조할 수 있는 전형적인 해결방식
	- 개발시간 단축, 안정적 개발 가능
	- 패턴
		- Layers Pattern  
			![image](https://user-images.githubusercontent.com/53277342/153587030-051e700f-5cf7-446d-9258-c8f276929226.png)
			- 시스템을 계층화해 구성
			- 상위 계층은 하위 계층에 대한 서비스 제공자, 하위 계층은 상위 계층에 대한 클라이언트
			- 서로 마주보는 두 계층 사이에서만 상호작용 이뤄짐
			- ex) OSI 7 Layer
		- Client-Server Pattern  
			![image](https://user-images.githubusercontent.com/53277342/153587059-b7f5f865-8573-4147-b4ac-f494a6df8d4c.png)
			- 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성
			- 사용자는 클라이언트 통해 서버 요청, 클라이언트 응답 받아 사용자에게 제공
		- Pype-Filter Pattern  
			![image](https://user-images.githubusercontent.com/53277342/153587129-17031df9-d1c6-4e80-9d9c-b191ffa77450.png)
			- 데이터 스트림(송수신 흐름) 절차의 각 단계를 필터 컴포넌트로 캡슐화, 파이프 통해 데이터 전송
			- 재사용성 좋고 확장 용이
			- 필터간 데이터 이동 시 데이터 변환으로 인한 오버헤드 발생
			- ex) UNIX의 Shell
		- MVC Pattern (Model-View-Controller)  
			![image](https://user-images.githubusercontent.com/53277342/153587777-77fee720-882a-42da-905d-84f09da062a3.png)
			- 서브시스템을 3개의 부분으로 구조화
			- 부분
				- Model: 서브시스템의 핵심 기능, 데이터 보관
				- View: 사용자에게 정보 표시
				- Controller: 사용자로부터 받은 입력 처리
			- 대화형 어플리케이션에 적합
		- Master-Slave Pattern  
			![image](https://user-images.githubusercontent.com/53277342/153587887-d0592666-ceb4-4f87-864e-3d8e16acfaf1.png)
			- 마스터 컴포넌트는 슬레이브 컴포넌트로 작업 분할, 슬레이브 컴포넌트에서 처리된 결과물 받음
			- 장애 허용 시스템, 병렬 컴퓨팅 시스템에서 주로 활용
		- Broker Pattern  
			![image](https://user-images.githubusercontent.com/53277342/153588082-fade5427-9599-4845-b2cc-4872cbc7007f.png)
			- 사용자가 원하는 서비스 브로커 컴포넌트에 요청, 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자 연결
			- 원격 호출에 응답하는 컴포넌트들이 여러 개 있을 때 적합
			- 분산 환경 시스템에서 주로 활용
		- Peer-To-Peer Pattern  
			![image](https://user-images.githubusercontent.com/53277342/153588440-2e261173-6517-4a85-9220-b56e40a0e569.png)
			- 피어를 하나의 컴포넌트로 간주, 상황에 따라 서버, 클라이언트가 될 수 있음
			- 멀티스레딩 방식 사용
		- Event-Bus Pattern  
			![image](https://user-images.githubusercontent.com/53277342/153588619-deeb9f3c-2b61-4313-972e-ef7755fa29ad.png)
			- 소스가 특정 채널에 이벤트 메시지 발행, 해당 채널 구독한 리스너들이 메시지 받아 이벤트 처리
			- 주요 컴포넌트
				- Source: 이벤트 생성
				- Listener: 이벤트 수행
				- Channel: 이벤트 통로
				- Bus: 채널들 관리
		- Blackboard Pattern  
			![image](https://user-images.githubusercontent.com/53277342/153588826-96a97df0-582a-4468-8ff1-d9866ae5d43e.png)
			- 컴포넌트들은 검색 통해 블랙보드에서 원하는 데이터 찾음
			- 해결책이 명확하지 않은 문제 처리할 때 유용
			- ex) 음성 인식, 차량 식별, 신호 해석
		- Interpreter Pattern  
			![image](https://user-images.githubusercontent.com/53277342/153589303-bc215e87-453a-4985-827f-6cd1c945217a.png)
			- 특정 언어로 작성된 프로그램 코드 해석하는 컴포넌트 설계할 때 사용됨

3. Object-Oriented (객체지향)
	- 소프트웨어를 개발할 때 객체들을 조립해서 작성하는 기법
	- 재사용 및 확장 용이, 복잡한 구조를 단계적 계층적으로 표현
	- 객체 (Object)
		- 데이터(Attribute)와 함수(Operation)를 묶어놓은 하나의 소프트웨어 모듈
		- 시간에 따라 상태 변화
	- 클래스 (Class)
		- 공통된 속성과 행위를 갖는 객체의 집합
		- Instance: 클래스에 속한 각각의 객체
		- Instantiation(인스턴스화): 클래스로부터 객체 생성하는 것
		- 최상위 클래스: 상위 클래스를 갖지 않는 클래스
		- Super Class: 상위(부모) 클래스, Sub Class: 하위(자식) 클래스
	- 상속 (Inheritance)
		- 기존 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것
		- 재정의할 필요 없으며 새로운 속성과 연산 첨가 가능
		- 소프트웨어의 재사용성 향상
		- 다중 상속 (Multiple Inheritance): 한 개의 하위 클래스가 두 개 이상의 상위 클래스로부터 상속받는 것
	- 다형성 (Polymorphism)
		- 하위 객체들이 서로 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질
	- 연관성 (Relationship)
		- 상호 참조하는 관계

4. OOA (Object Oriented Analysis, 객체지향 분석)
	- 사용자의 요구사항 분석해 모든 클래스에 대한 속성 관계 정의해 모델링하는 작업
	- 방법론
		- Rumbaugh(럼바우) 방법
			- 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용해 모델링
			1. 객체 모델링
				- 객체들 간 관계 규정해 객체 다이어그램으로 표시
			2. 동적 모델링
				- 시간의 흐름에 따른 동적인 행위 표현하는 모델링
			3. 기능 모델링
				- DFD 이용해 자료 흐름 중심으로 처리 과정 표현한 모델링
		- Booch(부치) 방법: 미시적 개발, 거시적 개발
		- Jacobson 방법: Use Case 강조해 사용하는 분석 방법
		- Coad와 Yourdan 방법: E-R Diagram 사용해 객체 행위 모델링
	- 객체지향 설계원칙 
		- 단일 책임 원칙 (SRP, Single Responsibility Principle)
			- 객체는 단 하나의 책임만 가져야 한다는 원칙
			- 응집도 높고, 결합도 낮게 설계
		- 개방-폐쇄 원칙 (OCP, Open-Closed Principle)
			- 기존 코드 변경 없이 기능 추가할 수 있도록 설계
		- 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)
			- 자식 클래스는 부모 클래스의 책임 무시하거나 재정의하지 않고, 확장만 수행
		- 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)
			- 사용하지 않는 인터페이스와 의존관계를 맺거나 영향 받지 않아야 한다는 원칙
			- 인터페이스가 갖는 책임
		- 의존 역전 원칙 (DIP, Dependency Inversion Principle)
			- 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙

5. Module
	- 모듈화를 통해 분리된 시스템의 각 기능들
	- 단독 컴파일 가능, 재사용 가능
	- 독립성
		- 각 모듈의 기능이 서로 독립된 정도
		- 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호작용 배제해야
		- 독립성 높을수록 모듈을 수정할 때 다른 모듈에게 영향 거의 없음, 오류 쉽게 발견 및 해결
		- 결합도 약할수록, 응집도 강할수록 독립성 높음
			- 결합도(Coupling)
				- 모듈 간 상호 의존하는 정도
				![image](https://user-images.githubusercontent.com/53277342/153824284-8cbd84f1-85c7-4cf0-9056-a85318720f09.png)
				- 자료 결합도(Data Coupling)
					- 모듈 간 인터페이스가 자료 요소로만 구성될 때 결합도
				- 스탬프(검인) 결합도(Stamp Coupling)
					- 모듈 간 인터페이스로 자료구조가 전달될 때의 결합도
				- 제어 결합도(Control Coupling)
					- 제어 신호를 이용하여 통신하거나 제어 요소를 전달하는 결합도
					- 제어 신호 이동하여 권리 전도현상 발생
						- 권리 전도현상: 하위 모듈이 상위 모듈에게 처리 명령 내림
				- 외부 결합도(External Coupling)
					- 어떤 모듈에서 선언한 데이터를 다른 외부 모듈에서 참조할 때의 결합도
				- 공통(공유) 결합도(Common Coupling)
					- 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
				- 내용 결합도(Content Coupling)
					- 한 모듈이 다른 모듈의 내부 기능 및 자료를 직접 참조하거나 수정할 때의 결합도
					
			- 응집도(Cohesion)
				- 모듈의 내부 요소들의 서로 관련되어있는 정도  
				![image](https://user-images.githubusercontent.com/53277342/153825119-f40ac0cf-1dbb-4103-8fb1-817e1888fc7b.png)
				- 기능적 응집도(Functional Cohesion)
					- 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 때의 응집도
				- 순차적 응집도(Sequential Cohesion)
					- 하나의 활동으로부터 나온 출력을 다음 활동의 입력으로 사용할 때의 응집도
				- 교환(통신)적 응집도(Communication Cohesion)
					- 동일 입출력을 사용하여 서로 다른 기능을 수행할 경우의 응집도
				- 절차적 응집도(Procedural Cohesion)
					- 모듈 안 구성요소들이 기능을 순차적으로 수행할 경우의 응집도
				- 시간적 응집도(Temporal Cohesion)
					- 특정 시간에 처리되는 기능을 모아 하나의 모듈로 작성할 경우의 응집도
				- 논리적 응집도(Logical Cohesion)
					- 유사한 성격 및 특정 형태로 분류되는 요소들을 하나의 모듈로 작성할 경우의 응집도
				- 우연적 응집도(Coincidental Cohesion)
					- 서로 관련 없는 요소로만 구성된 경우의 응집도

	- Fan-In / Fan-Out
		- 시스템 복잡도 알 수 있음
		- Fan-In 높을수록, Fan-Out 낮을수록 설계해야 함
		- Fan-In
			- 어떤 모듈을 제어하는 모듈의 수, 직접적으로 받는 화살표 개수
			- 높을수록 재사용 측면에서 잘 설계됨
			- 단일 장애점 발생 가능하므로 중점적인 관리 및 테스트 필요
				- 단일 장애점: 시스템 구성 요소 중 동작하지 않으면 전체 시스템이 중단되는 요소
		- Fan-Out: 어떤 모듈에 의해 제어되는 모듈의 수, 직접적으로 뻗는 화살표 개수
			- 높은 경우 불필요하게 다른 모듈 호출하는지 검토 및 단순화 검토

	- N-S Chart (Nassi-Schneiderman Chart)
		- 논리의 기술에 중점을 둔 도형을 이용한 표현 방법, 박스 다이어그램
		- 제어 논리구조 표현, GoTo 및 화살표 사용 안 함
		- 조건 처리를 시각적으로 명확히 식별하는 데 적합

6. 공통 모듈
	- 여러 프로그램에서 공통적으로 사용할 수 있는 모듈
	- 자주 사용되는 기능들을 공통 모듈로 구성
	- 모듈의 재사용성 확보, 중복 개발 회피 위해 공통 부분 식별, 명세 작성
	- 명제 작성 기법
		- 정확성(Correctness): 해당 기능 필요하다는 것 알 수 있도록 정확히 작성
		- 명확성(Clarity): 중의적으로 해석되지 않도록 명확히 작성
		- 완전성(Completeness): 구현 위해 필요한 모든 것 기술
		- 일관성(Consistency): 공통 기능들 간 상호 충돌 발생하지 않도록 작성
		- 추적성(Traceability): 기능에 대한 관계 파악할 수 있도록 작성
	- 재사용
		- 비용과 개발 시간 절약 위해 이미 개발된 기능 파악 및 재구성
		- 규모에 따른 분류
			- 함수와 객체: 소스코드 재사용
			- 컴포넌트: 인터페이스 통해 통신
			- 어플리케이션: 어플리케이션 공유

7. Code
	- 자료 처리하는 과정에서 분류 및 추출 쉽게 하기 위해 사용하는 기호
	- 주요 기능
		- 식별, 분류, 배열, 표준화, 간소화 기능
	- 종류
		- 순차 코드 (Sequence Code)
			- 순서대로 일련번호 부여하는 방법
			- ex) 1, 2, 3, 4 ..
		- 블록 코드 (Block Code)
			- 공통성이 있는 것끼리 블록 구분, 각 블록 내에서 일련번호 부여
			- ex) 1001~1100: 총무부, 1101~1200: 영업부
		- 10진 코드 (Decimal Code)
			- 대상 항목을 10진 분할, 다시 각각에 대해 10진 분할
			- ex) 1000: 공학 -> 1100: 소프트웨어 공학 -> 1110: 소프트웨어 설계
		- 그룹 분류 코드 (Group Classification Code)
			- 대상 항목을 대분류, 중분류, 소분류 등으로 구분
			- 각 그룹 내에서 일련번호 부여
			- ex) 1-01-001: 본사-총무부-인사계, 2-01-001: 지사-총무부-인사계
		- 연상 코드 (Mnemonic Code)
			- 대상 항목의 명칭이나 약호와 관련있는 기호 사용
			- ex) TV-40: 40인치 TV
		- 표의 숫자 코드 (Siginificant Digit Code)
			- 대상 항목의 성질을 그대로 코드에 적용시키는 방법
			- ex) 120-720-1500: 두께-폭-길이 강판
		- 합성 코드 (Combined Code)
			- 하나의 코드로 표현하기 어려운 경우 2개 이상의 코드 조합한 코드
			- ex) 연상 코드 + 순차 코드
				- KE-711: 대한항공 711기, AC-253: 에어캐나다 253기

8. Design Pattern ** 추후 보강

## 4. 인터페이스 설계
1. 인터페이스 요구사항 검증
	- 인터페이스 설계 전 요구사항이 요구사항 명세서에 정확히 기술됐는지 검토 및 베이스라인 설정
	- 과정
		1. 요구사항 검토 계획 수립
			- 검토 기준 및 방법, 참여자, 체크리스트, 관련 자료, 일정
		2. 검토 및 오류 수정
		3. 베이스라인 설정
			- 베이스라인: 개발 범위 기준
	- 방법
		- 요구사항 검토
			- 동료 검토(Peer Review): 요구사항 명세서 작성자가 직접 설명, 동료들이 들으면서 결함 발견
			- 워크 스루(Walk Through): 회의 전 명세서 미리 배포해 사전 검토, 회의 통해 발견
			- 인스펙션(Inspection): 명세서 작성자 제외한 다른 검토 전문가들이 발견
		- 프로토타이핑
			- 견본품 만들어 최종 결과물 예측
		- 테스트 설계
			- 테스트 케이스 생성해 요구사항이 현실적으로 테스트 가능한지 검토
		- CASE(Computer Aided Software Engineering) 도구 활용
			- 일관성 분석 통해 요구사항 변경사항 확인
	- 주요 항목
		- 완전성, 일관성, 명확성, 기능성, 검증 가능성, 추적 가능성, 변경 용이성

2. 인터페이스 방법 명세화
	- 내외부 시스템이 연계해서 작동할 때 다양한 정보를 문서로 명확히 정리하는 것
	- 명세 정보
		- 시스템 연계 기술
			- 개발할 시스템, 내외부 시스템 연계할 때 사용되는 기술
			- 예시
				- DB Link: DB에서 제공하는 객체 이용하는 방식
				- API/Open API: DB에서 데이터 읽어와 제공하는 API
				- 연계 솔루션: EAI 서버와 클라이언트 이용하는 방식
				- Socket: 서버는 소켓 생성해 포트 할당하고 클라이언트 요청 시 연결하는 방식
				- Web Service: WSDL, UDDI, SOAP 프로토콜 이용하는 서비스
		- 인터페이스 통신 유형
			- 개발할 시스템, 내외부 시스템 간 데이터 송수신하는 형태
			- 유형
				- 단방향: 거래 요청만 하고 응답 없는 방식
				- 동기: 거래 요청하고 응답올 때까지 대기(Request-Reply)
				- 비동기: 거래 요청하고 다른 작업 수행하다 응답 오면 처리(Send-Receive-Acknowledge)
		- 인터페이스 처리 유형
			- 송수신 데이터를 어떤 형태로 처리할 것인지 방식
			- 유형
				- 실시간 방식: 요청한 내용 바로 처리해야할 때 사용
				- 지연 처리 방식: 비용 많이 발생할 때 사용
				- 배치 방식: 대량의 데이터 처리할 때 사용
		- 인터페이스 발생 주기
			- 개발할 시스템, 내외부 시스템 간 인터페이스가 사용되는 주기
		- 송수신 방법 명세화
			- 내외부 인터페이스 목록에 있는 인터페이스에 관한 송수신 방법 정의
			- ex) 업무 및 데이터 성격, 연계 데이터 발생 건수, 연계 시스템의 기술 구조, 시스템간 성능
		- 송수신 데이터 명세화
			- 내외부 인터페이스 목록에 있는 인터페이스에 필요한 송수신 데이터에 대한 명세
			- 테이블 정의서, 테이블 또는 파일 단위로 명세 작성
		- 오류 식별 및 처리 방안 명세화
			- 발생할 수 있는 오류 식별, 오류 처리 방안에 대한 명세 작성
			- 오류 코드: 오류 발생 영역 구분자, 오류 그룹번호로 작성

3. 미들웨어 솔루션 명세
	- 미들웨어
		- 분산 컴퓨팅 환경에서 서로 다른 기종을 연결해 원만한 통신이 이뤄지도록 서비스를 제공하는 소프트웨어
		- 위치 투명성 제공
			- 위치 투명성: 접근하려는 시스템의 실제 위치 알 필요 없이 명칭만으로 접근 가능함
		- 종류
			- DB (DataBase)
				- 클라이언트에서 원격 데이터베이스와 연결하기 위한 미들웨어
				- ex) ODBC, IDAPI, Glue
			- RPV (Remote Procedure Call, 원격 프로시저 호출)
				- 응용 프로그램의 프로시저 이용해 원격 프로시저를 로컬 프로시저처럼 호출하는 미들웨어
					- 프로시저: DB에 대한 쿼리를 하나의 함수처럼 실행하기 위한 쿼리의 집합
				- ex) Entera, ONC/RPC
			- MOM (Message Oriented Middleware, 메시지 지향 미들웨어)
				- 비동기형 메시지를 전달하는 방식의 미들웨어
				- ex) MQ, Message Q, JMS
			- TP-Monitor (Transaction Processing Monitor, 트랜잭션 처리 모니터)
				- 트랜잭션 처리 및 감시하는 미들웨어
					- 트랜잭션 처리: 여러 이용자가 실시간으로 데이터 갱신하거나 검색하는 작업 처리
				- 사용자 수가 증가해도 빠른 응답속도 유지해야 하는 업무에 사용
				- ex) tuxedo, tmax
			- ORB (Object Request Broker, 객체 요청 브로커)
				- CORBA (Common Object Request Broker Application) 표준 스펙 구현
					- CORBA: 분산 프로그램 객체 생성, 배포, 관리하기 위한 규격
				- ex) Orbix, CORBA
			- WAS (Web Application Server, 웹 어플리케이션 서버)
				- 사용자의 요구에 따라 변하는 동적 컨텐츠를 처리하기 위해 사용되는 미들웨어
				- ex) WebLogic, WebSphere
		- 미들웨어 솔루션 식별
			- 미들웨어 솔루션 확인 및 목록 작성
		- 미들웨어 솔루션 명세서 작성
			- 미들웨어 솔루션 목록의 솔루션별로 관련 정보 상세 기술


                             












