# Software Development

## Contents  
[**1. 데이터 입출력 구현**](#1-데이터-입출력-구현)  
[**2. 통합 구현**](#2-통합-구현)  
[**3. 제품 소프트웨어 패키징**](#3-제품-소프트웨어-패키징)  
[**4. 어플리케이션 테스트 관리**](#4-어플리케이션-테스트-관리)  
[**5. 인터페이스 구현**](#5-인터페이스-구현)  

----

## 1. 데이터 입출력 구현
1. 자료구조
	- 프로그램에서 사용하기 위한 자료를 저장하는 방법, 자료간의 관계 및 처리방법 연구분석
	- 종류
		- 선형 리스트 (Linear List)
			- 일정한 순서에 의해 나열된 자료 구조
			- 종류
				- 연속 리스트 (Contiguous List)
					- 연속된 기억장소에 저장되는 자료구조(배열)
					- 기억장소 이용효율 밀도 1 (좋음)
				- 연결 리스트 (Linked List)
					- 노드의 포인터 이용해 순서에 따라 서로 연결시킨 자료구조
					- 연속적으로 놓여있지 않아도 저장 가능
					- 노드 삽입 및 삭제 작업 용이
					- 기억 공간의 이용 효율 안 좋음, 접근 속도 느림
		- 스택 (Stack)
			- LIFO 방식의 자료구조
			- Overflow: 공간이 모두 채워져 있는 상태에서 데이터 삽입
			- Underflow: 더 이상 삭제할 데이터가 없는 상테에서 데이터 삭제
		- 큐 (Queue)
			- FIFO 방식의 자료구조
			- 포인터 구성
				- Front Pointer: 가장 먼저 삽입된 자료의 기억 공간 가리킴
				- Rear Pointer: 가장 마지막에 삽입된 자료의 기억 공간 가리킴
		- 그래프 (Graph)
			- 정점(Vertex)과 간선(Edge)로 구성된 자료구조
			- 방향성 유무에 따라 방향 그래프, 무방향 그래프로 구분
			- 트리(Tree)
				- 정점(Node)과 선분(Branch)을 이용해 사이클 이루지 않도록 구성한 그래프
				- 용어
					- Node: 하나의 기억 공간
					- Root Node: 트리의 맨 위에 있는 노드
					- Degree(차수): 각 노드에서 뻗어나온 가지의 수
					- Terminal Node(= Leaf Node): 자식이 없는 노드
					- Son Node: 어떤 노드에 연결된 다음 레벨의 노드
					- Parent Node: 어떤 노드에 연결된 이전 레벨의 노드
					- Brother Node(= Sibling): 동일한 부모를 갖는 노드들
					- 트리의 차수: 차수들 중 가장 많은 수
				- 운행법 (Traversal)
					- 트리를 구성하는 각 노드들을 찾아가는 방법
					- Preorder: Root -> Left -> Right
					- Inorder: Left -> Root -> Right
					- Postorder: Left -> Right -> Root

2. 정렬
	- 삽입 정렬 (Insertion Sort, O(n^2))
		- 모든 원소를 앞에서부터 정렬된 부분과 비교해 자신의 위치에 맞는 곳에 삽입  
		<img src="https://user-images.githubusercontent.com/53277342/154679777-087513d1-aa63-4bce-8c25-03aebd2a5379.png" width="50%"/>
		<img src="https://user-images.githubusercontent.com/53277342/154679792-a137372a-169d-4a61-a89e-bbbf45344b33.png" width="50%"/>
	- 셸 정렬 (Shell Sort, 평균 O(n^1.5), 최악 O(n^2))
		- 특정 매개변수 값의 길이를 갖는 부분 리스트 여러 개 생성 후 삽입 정렬  
		<img src="https://user-images.githubusercontent.com/53277342/154680229-cf7b7c39-8923-43c0-a6c2-994eca1fbd70.png" width="50%"/>
	- 선택 정렬 (Selection Sort, O(n^2))
		- 모든 원소 중 최소값을 찾아 맨 앞에 있는 값과 교체  
		<img src="https://user-images.githubusercontent.com/53277342/154680874-de35524e-b172-42da-88d1-227f547a41ee.png" width="50%"/>
	- 버블 정렬 (Bubble Sort, O(n^2))
		- 인접한 두 원소를 비교해 교차하면서 정렬  
		<img src="https://user-images.githubusercontent.com/53277342/154681177-086e47f5-09b8-4576-8f2b-8fd253d8cbba.png" width="50%"/>
	- 퀵 정렬 (Quick Sort, 평균 O(nlogn), 최악 O(n^2))
		- Pivot 기준으로 부분 리스트로 분할 후 정렬  
		<img src="https://user-images.githubusercontent.com/53277342/154682153-c8ba59f4-a442-4386-895a-83336b783c80.png" width="50%"/>
	- 힙 정렬 (Heap Sort, O(nlogn))
		- 전이진 트리(Complete Binary Tree)에서 자식 노드와 부모 노드 비교해 정렬  
		<img src="https://user-images.githubusercontent.com/53277342/154683949-a7aa3caa-771c-44d2-8077-1bb728135c81.png" width="70%"/>
	- 합병 정렬 (Merge Sort, O(nlogn))
		- 이미 정렬되어있는 두 개의 리스트를 하나로 합병 후 정렬  
		<img src="https://user-images.githubusercontent.com/53277342/154684156-c3c69835-07c0-46b0-bf51-59faba607c5e.png" width="50%"/>
	- 기수 정렬 (Radix Sort, O(dn))
		- 자릿수별로 정렬  
		<img src="https://user-images.githubusercontent.com/53277342/154685160-29bf5d15-efd3-4947-b418-caf6d725d86c.png" width="70%"/>

3. 데이터베이스
	- 업무를 수행하는데 필요한 데이터들의 모임
	- 특징
		- 통합된 데이터 (Integrated Data): 중복을 배제한 데이터의 모임
		- 저장된 데이터 (Stored Data): 저장매체에 저장된 자료
		- 운영 데이터 (Operational Data): 존재 가치가 확실하고 없어서는 안 되는 자료
		- 공용 데이터 (Shared Data): 여러 응용 시스템들이 공동 소유 및 유지
	- DBMS (DataBase Management System, 데이터베이스 관리 시스템)
		- 사용자와 DB 사이에서 사용자의 요구에 따라 정보 생성 및 DB 관리해주는 소프트웨어
		- 데이터 종속성, 중복성 배제
		- 기능
			- 정의 (Definition)
				- DB에 저장될 데이터의 타입, 구조 정의, 이용 방식, 제약 조건 명시
			- 조작 (Manipulation)
				- 데이터 검색, 갱신, 삽입, 삭제하기 위한 인터페이스 수단 제공
			- 제어 (Control)
				- 데이터 무결성 유지되도록 제어
				- 허가된 데이터만 접근할 수 있도록 권한 검사
				- 여러 사용자가 동시 접근할 때 정확성 유지하도록 병행 제어 (Concurrency Control)
	- 스키마 (Schema)
		- DB 구조와 제약 조건에 관한 명세를 기술한 메타데이터의 집합
		- 사용자의 관점에 따른 분류
			- 외부 스키마: 각 개인의 입장에서 DB의 논리적 구조
			- 개념 스키마: 모든 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 DB 논리적 구조, 하나만 존재
			- 내부 스키마: 물리적 저장장치 입장의 DB 구조, 형식 및 표현방법, 물리적 순서 나타냄

4. 절차형 SQL
	- 연속적인 실행이나 제어가 가능한 SQL
	- 저장 모듈 생성 가능, 입출력 패킷 적은 편, 기능별 모듈화 가능
	- 종류
		- 프로시져 (Procedure): 호출을 통해 미리 저장해놓은 SQL 작업 수행
		- 트리거 (Trigger): 이벤트 발생할 때마다 관련 작업 자동 수행
		- 사용자 정의 함수: 일련의 작업 연속 처리, 처리 결과 단일값 반환
	- 쿼리 성능 최적화
		- 데이터 입출력 어플리케이션 성능 향상 위해 SQL 코드 최적화
		- APM 사용해 최적화할 쿼리 선정
			- APM: SQL이 효율적으로 수행되도록 최적의 경로 찾아주는 모듈

## 2. 통합 구현
1. 단위 모듈 테스트
	- 프로그램의 단위 기능 모듈이 정해진 기능 정확히 수행하는지 검증
	- 기법
		- 화이트박스 테스트
			- 모듈의 소스코드 오픈시킨 상태에서 모든 논리적인 경로 테스트
		- 블랙박스 테스트
			- 특정 기능이 완전히 작동되는 것 입증하는 테스트
	- 테스트 케이스 구성 요소
		- 식별자, 테스트 항목, 입출력 명세, 환경 설정, 특수 절차 요구, 의존성 기술
	- 테스트 프로세스
		1. 계획 및 제어
		2. 분석 및 설계: 테스트 시나리오, 테스트 케이스 작성
			- 테스트 시나리오: 테스트 케이스들을 묶은 집합
		4. 구현 및 실현: 테스트 프로시저 명세
			- 테스트 프로시저: 테스트 케이스의 실행 순서, 테스트 스크립트
		5. 평가
		6. 완료

2. 개발 지원 도구
	- IDE (Integrated Development Environment, 통합 개발 환경)
		- 편집기(Editor), 컴파일러(Compiler), 디버거(Debugger)를 하나의 인터페이스로 통합
	- 빌드 도구
		- 소스 코드 파일들을 컴퓨터에서 실행할 수 있는 소프트웨어로 변환하는 소프트웨어
		- 전처리, 컴파일 등의 작업 수행
		- ex) Ant, Maven, Gradle

## 3. 제품 소프트웨어 패키징
1. 소프트웨어 패키징
	- 모듈별로 생성한 실행 파일들 묶어 배포용 설치 파일 만드는 것
	- 사용자 중심 진행, 모듈화하여 패키징
	- 작업 순서
		1. 기능 식별: 코드 기능 확인
		2. 모듈화: 기능단위 코드 분류
		3. 빌드 진행: 모듈단위 실행파일 생성
		4. 사용자 환경 분석: 최소 운영환경 정의
		5. 패키징 및 적용 시험: 패키징, 테스팅, 사용자 입장에서 불편사항 확인
		6. 패키징 변경 개선: 불편사항 반영 패키징 개선
		7. 배포

2. 릴리즈 노트 작성
	- 릴리즈 정보를 고객과 공유하기 위한 문서
	- 작성 순서
		1. 모듈 식별: 모듈별 빌드 수행 후 릴리즈 노트에 작성될 내용 확인
		2. 릴리즈 정보 확인
		3. 릴리즈 노트 개요 작성: 간략한 내용 작성
		4. 영향도 체크: 해당 릴리즈 버전의 기능 변화가 다른 기능에 미치는 영향 기술
		5. 정식 릴리즈 노트 작성
		6. 추가 개선 항목 식별

2. 디지털 저작권 관리 (DRM, Digital Right Management)
	- 저작권: 창작자가 가지는 배타적 독점적 권리
	- DRM: 저작권자가 의도한 용도로만 사용되도록 하는 디지털 컨텐츠 관리 및 보호 기술  
	![image](https://user-images.githubusercontent.com/53277342/154802081-4e2dfc77-a4ab-486a-84ca-c2ce40460403.png)
	- 구성 요소
		- 클리어링 하우스: 저작권 관리를 수행하는 곳
		- 컨텐츠 제공자: 컨텐츠 제공하는 저작권자
		- 패키저: 컨텐츠와 메타 데이터를 배포 가능한 형태로 묶어 암호화하는 프로그램
		- 컨텐츠 분배자: 암호화된 컨텐츠를 유통하는 곳
		- 컨텐츠 소비자: 컨텐츠 구매해서 사용하는 주체
		- DRM 컨트롤러: 배포된 컨텐츠의 이용 권한 통제하는 프로그램
		- 보안 컨테이너: 컨텐츠 원본을 안전하게 유통하기 위한 전자적 보안장치
	- 기술 요소
		- 암호화: 컨텐츠 및 라이선스 암호화
		- 키 관리: 암호화한 키 저장 및 분배 기술
		- 암호화 파일 생성: 암호화된 컨텐츠로 생성하기 위한 기술
		- 식별 기술: 컨텐츠에 대한 식별 체계 표현 기술
		- 저작권 표현: 라이선스 내용 표현 기술
		- 정책 관리: 라이선스에 대한 정책 표현 및 관리 기술
		- 크랙 방지: 크랙에 의한 컨텐츠 사용 방지 기술
		- 인증: 라이선스 사용 기준이 되는 사용자 인증 기술

3. 소프트웨어 설치 메뉴얼
	- 사용자가 소프트웨어를 설치하는 과정에 필요한 내용 기록한 설명서
	- 구성
		1. 목차 및 개요
		2. 서문
			- 문서 이력, 설치 메뉴얼의 주석, 설치 도구의 구성, 설치 환경 체크 항목
		3. 기본 사항
			- 개요, 설치 관련 파일, 설치 아이콘, 프로그램 삭제, 관련 추가 정보

4. 소프트웨어 사용자 메뉴얼
	- 사용자가 소프트웨어를 사용하는 과정에서 필요한 내용 기록한 설명서
	- 구성
		1. 목차 및 개요
		2. 서문
			- 문서 이력, 사용자 메뉴얼의 주석, 기록 보관 내용
		3. 기본 사항
			- 개요, 사용 환경, 관리, 버전별 특징, 인터페이스 특징, 구동 환경

5. 소프트웨어 버전 등록
	- 형상관리 (SCM, Software Configuration Management)
		- 소프트웨어의 변경사항 관리하기 위한 활동
		- 가시성, 추적성 보장으로 생산성, 품질 증대
		- 기능
			- 형상 식별: 형상 관리 대상에 관리 번호 부여해 수정 및 추적 용이
			- 버전 제어: 생성된 다른 버전의 형상 항목 관리
			- 형상 통제 (변경 관리): 변경 요구 검토
			- 형상 감사: 무결성 평가 후 공식적으로 승인
			- 형상 기록 (상태 보고): 형상 기록, 관리
		- 버전 등록 용어
			- Repository: 정보들이 저장되어 있는 곳
			- Import: 아무것도 없는 저장소에 처음으로 파일 복사
			- Check-Out: 프로그램 수정 위해 저장소에서 파일 받아옴
			- Check-In: 체크아웃한 파일 수정 완료 후 새로운 버전으로 갱신
			- Commit: 체크인 수행할 때 Conflict 확인, 수정 후 갱신 완료
			- Update: 저장소에 있는 최신 버전으로 동기화
		- 버전 등록 과정
			1. Import
			2. Check-Out
			3. Commit
			4. Update
			5. Diff

6. 소프트웨어 버전 관리 도구
	- 공유 폴더 방식
		- 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리
	- 클라이언트/서버 방식
		- 버전 관리 자료가 서버에 저장되어 관리
	- 분산 저장소 방식
		- 버전 관리 자료가 하나의 원격 저장소와 분산된 개발자의 로컬 저장소에 저장되어 관리
	- Subversion (SVN)
		- 서버의 자료를 클라이언트로 복사해 작업한 후 변경내용 서버에 반영
	- Git
		- 분산 버전 관리 시스템
		- 주요 용어
			- 지역 저장소: 개발자들이 실제 개발을 진행하는 장소
			- 원격 저장소: 협업을 위해 버전을 공동 관리하는 곳
			- Staging Area: 작업 내용을 한번 더 확인하여 안정된 버전 관리 위한 장소
			- Branch: 독립적으로 동시에 작업 진행 가능하며 마무리되면 Master Branch에 병합
			- add: 작업 내역 지역 저장소에 저장하기 위해 Staging Area에 추가
			- commit: 작업 내역 지역 저장소에 저장
			- checkout: 지정한 브랜치로 이동
			- merge: 지정한 브랜치의 변경 내역을 HEAD 포인터가 가리키는 브랜치에 병합
			- init: 지역 저장소 생성
			- remote add: 원격 저장소 연결
			- push: 로컬 저장소 변경 내역을 원격 저장소에 반영
			- fetch: 원격 저장소의 변경 이력을 지역 저장소로 가져와 반영
			- clone: 원격 저장소의 전체 내용을 지역 저장소로 복제
			- fork: 지정한 원격 저장소의 내용을 자신의 원격 저장소로 복제

7. 빌드 자동화 도구
	- 빌드: 소스코드 컴파일 후 여러 모듈 묶어 실행 파일로 만드는 과정
	- 빌드 자동화 도구: 빌드, 테스트, 배포 자동화 도구
	- CI (Contiunous Integration, 지속적인 통합)
		- Agile 환경에서 작업 마무리 될 때마다 모듈 단위로 나눴던 코드들 지속적으로 통합
	- 예시
		- Jenkins
			- Java 기반 오픈소스 빌드 자동화 도구, 가장 많이 이용, Web GUI 제공
			- 분산 빌드 및 테스트 가능
		- Gradle
			- Groovy 기반 오픈소스 빌드 자동화 도구, 안드로이드 환경에서 사용
			- 처리 명령 모아 Task로 만들어 Task 단위 실행
			- 빌드 캐시 기능 지원으로 빌드 속도 향상
		
## 4. 어플리케이션 테스트 관리
1. 어플리케이션 테스트
	- 어플리케이션에 잠재되어있는 결함 찾아내는 과정
	- Validation (확인): 사용자 입장에서 요구사항에 맞게 구현되었는지 확인, 결과 테스트
	- Verification (검증): 개발자 입장에서 명세서에 맞게 구현되었는지 확인, 과정 테스트
	- 분류
		- 프로그램 실행 여부
			- 정적 테스트
				- 프로그램 실행 없이 명세서나 소스 코드 대상으로 분석
				- 개발 초기에 결함 발견 가능
				- ex) 워크스루, 인스펙션, 코드 검사
			- 동적 테스트
				- 프로그램 실행해 오류 찾는 테스트
				- 개발 모든 단계에서 테스트 수행 가능
				- 화이트박스 테스트
					- 모듈의 원시 코드 오픈시킨 상태에서 테스트케이스 설계
					- 종류
						- 기초 경로 검사: 논리적 복잡성 측정 가능
							- 기초 경로: 수행 가능한 모든 경로
						- 제어 구조 검사
							- 조건 검사: 논리적 조건 검사
							- 루프 검사: 반복 구조 초점 검사
							- 테이터 흐름 검사: 변수의 정의, 사용 위치에 초점 검사
				- 블랙박스 테스트
					- 각 기능이 작동되는 것을 입증하는 테스트, 기능 테스트
					- 종류
						- 동치 분할 검사: 입력 자료에 초점을 맞춘 테스트케이스 만들어 검사
						- 경계값 분석: 입력 조건의 경계값 테스트케이스에 추가
						- 원인-효과 그래프 검사: 입력 데이터간 관계 분석해 테스트케이스 선정
						- 오류 예측 검사: 과거의 경험, 확인자의 감각으로 테스트
						- 비교 검사: 여러 버전 프로그램에 동일 결과 출력되는지 테스트
		- 테스트 기반
			- 무엇을 기반으로 수행하는지
			- 명세 기반
				- 요구사항에 대한 명세를 빠짐없이 테스트케이스로 만들어 구현하고 있는지
				- ex) 동등 분할, 경계값 분석
			- 구조 기반
				- 내부 논리 흐름에 따라 테스트케이스 작성하고 확인
				- ex) 구문 기반, 결정 기반, 조건 기반
			- 경험 기반 테스트
				- 테스터의 경험을 기반으로 수행
				- 요구사항에 대한 명세 불충분, 시간 제약 있는 경우 수행
				- ex) 에러 추정, 체크 리스트, 탐색적 테스팅
		- 시각
			- 누구를 기준으로 테스트 하는지
			- 검증
				- 개발자의 시각에서 생산 과정 테스트
			- 확인
				- 사용자의 시각에서 제품 결과 테스트
		- 목적
			- 회복 (Recovery)
				- 프로그램에 결함 주어 실패하도록 한 뒤 올바르게 복구되는지 확인
			- 안전 (Security)
				- 시스템 보호도구가 불법적인 침입으로부터 시스템을 보호할 수 있는지 확인
			- 강도 (Stress)
				- 과부하 시에 소프트웨어가 정상적으로 실행되는지 확인
			- 성능 (Performance)
				- 실시간 성능, 전체적 효율성 진단
			- 구조 (Structure)
				- 내부의 논리적 경로, 소스 코드 복잡도 평가
			- 회귀 (Regression)
				- 변경된 코드에 새로운 결함 없음을 확인
			- 병행 (Parallel)
				- 변경된 소프트웨어와 기존 소프트웨어에 동일 데이터 입력해 결과 비교

2. 개발 단계에 따른 어플리케이션 테스트
	- 테스트 레벨: 소프트웨어의 개발 단계에 따라 테스트 분류
	![image](https://user-images.githubusercontent.com/53277342/154973621-37d5660f-6f61-457e-be92-595ae1b98bb3.png)
	- 단위 테스트
		- 코딩 직후 최소 단위 모듈, 컴포넌트에 초점
		- 방법
			- 구조 기반 테스트
				- 내부 구조, 복잡도 검증하는 화이트박스 테스트 시행
			- 명세 기반 테스트
				- 목적, 실행 코드 기반 블랙박스 테스트 시행
	- 통합 테스트
		- 단위 테스트 완료된 모듈 결합해 하나의 시스템으로 완성시키는 과정에서 테스트
		- 통합된 모듈간 상호작용 오류 검사
		- 방법
			- 비점진적 통합 방식
				- 단계적으로 통합하는 절차 없이 미리 결합되어있는 프로그램 전체 테스트
				- 빅뱅 통합 테스트 방식
					- 단위 테스트가 끝난 모듈 한꺼번에 결합시켜 테스트하는 방법
				- 오류 발견 및 장애 위치 파악, 수정 어려움
			- 점진적 통합 방식
				- 모듈 단위로 단계적으로 통합하면서 테스트
				- 하향식 통합 테스트
					1. 제어 모듈의 종속 모듈은 스텁으로 대체
						- 스텁: 일시적으로 필요한 조건만을 갖는 시험용 모듈
					2. 스텁들 하나씩 실제 모듈로 교체
					3. 모듈 통합될 때마다 테스트 실시
					4. 회귀 테스트 실시
				- 상향식 통합 테스트
					1. 하위 모듈 클러스터로 결합
						- 클러스터: 하나의 주요 제어모듈과 관련된 종속 모듈의 그룹
					2. 데이터 입출력 확인 위해 드라이버 작성
						- 드라이버: 하위 모듈 호출, 매개변수 전달, 테스트 수행 후 결과 도출 도구
					3. 통합된 클러스터 단위 테스트
					4. 클러스트들 하나씩 실제 모듈로 대체
				- 혼합식 통합 테스트
					- 하위 수준에서 상향식 통합 + 상위 수준에서 하향식 통합, 샌드위치식 통합 테스트
				- 회귀 테스팅
					- 이미 테스트된 프로그램의 테스팅 반복
	- 시스템 테스트
		- 해당 컴퓨터 시스템에서 완벽하게 수행되는지 점검
		- 실제 사용환경과 유사한 환경에서 테스트
		- 방법
			- 기능적 요구사항
				- 명세서 기반 블랙박스 테스트 시행
			- 비기능적 요구사항
				- 구조적 요소에 대한 화이트박스 테스트 시행
	- 인수 테스트
		- 사용자의 요구사항 충족하는지에 중점
		- 사용자가 직접 테스트
		- 종류
			- 사용자 인수 테스트
				- 사용자가 시스템 사용의 적절성 여부 확인
			- 운영상의 인수 테스트
				- 시스템 관리자가 백업/복원 시스템, 재난 복구, 사용자 관리 등 점검
			- 계약 인수 테스트
				- 계약상의 인수/검수 조건 준수하는지 여부 확인
			- 규정 인수 테스트
				- 정부 지침, 법규, 규정에 맞게 개발되었는지 확인
			- 알파 테스트
				- 개발자의 장소에서 사용자가 개발자 앞에서 테스트
				- 통제된 환경에서 시행
			- 베타 테스트
				- 선정된 사용자가 여러 사용자 앞에서 행하는 테스트, 필드 테스팅
				- 개발자에 의해 제어되지 않은 환경에서 시행

3. 테스트 케이스
	- 요구사항 정확히 준수했는지 확인하기 위한 테스트 항목 명세서
	- 작성 순서
		1. 테스트 계획 검토 및 자료 확보
		2. 위험 평가 및 우선순위 결정
		3. 테스트 요구사항 정의
		4. 테스트 구조 설계 및 테스트 방법 결정
		5. 테스트 케이스 정의
		6. 테스트 케이스 타당성 확인 및 유지보수
	- 테스트 시나리오
		- 테스트 케이스 적용하는 순서에 따라 여러 테스트 케이스들을 묶은 집합
		- 여러 개의 시나리오로 분리하여 작성
	- 테스트 오라클
		- 테스트 결과 올바른지 판단하기 위해 사전에 정의된 값 대입하여 비교
		- 특징
			- 제한된 검증: 모든 테스트 케이스에 적용 불가
			- 수학적 기법: 수학적 기법 사용해 테스트 오라클 값 구할 수 있음
			- 자동화 기능: 테스트 대상 프로그램 자동화 가능
		- 종류
			- 참 오라클: 모든 테스트 케이스 입력 값에 대한 기대값 제공
			- 샘플링 오라클: 특정 테스트 케이스의 입력 값만 기대값 제공
			- 추정 오라클: 샘플링 오라클 + 나머지 입력 값에 대해선 추정으로 처리
			- 일관성 검사 오라클: 테스트 케이스 수행 전 후 결과 같은지 확인

4. 테스트 자동화 도구
	- 사람이 반복적으로 수행하는 테스트 절차를 스트립트 형태로 자동화
	- 유형
		- 정적 분석 도구
			- 프로그램 실행하지 않고 분석
		- 테스트 케이스 생성 도구
			- 자료 흐름도
			- 기능 테스트
			- 입력 도메인 분석
			- 랜덤 테스트
		- 테스트 실행 도구
			- 데이터 주도 접근 방식
				- 테스트 데이터 저장해 실행
			- 키워드 주도 접근 방식
				- 수행할 동작 나타내는 키워드, 테스트 데이터 저장해 실행
		- 성능 테스트 도구
			- 가상의 사용자 만들어 테스트 수행하여 성능 목표 달성 여부 확인
		- 테스트 통제 도구
			- 형상 관리 도구
			- 결함 추적/관리 도구
		- 테스트 하네스 도구
			- 테스트를 지원하기 위해 생성된 코드와 데이터
		
5. 결함 관리
	- 개발자가 설계한 것과 다르게 동작하는 것
	- 프로세스
		1. 결함 관리 계획
		2. 결함 기록
		3. 결함 검토
		4. 결함 수정
		5. 결함 재확인
		6. 결함 상태 추적 및 모니터링
			- 지속적으로 상태 변화 추적, 관리해야 함
			- 측정 지표
				- 결함 분포: 결함 수 측정
				- 결함 추세: 결함 수 추이 분석
				- 결함 에이징: 결함 상태 지속 시간 측정
			- 추적 순서
				1. 결함 등록
				2. 결함 검토
				3. 결함 할당
				4. 결함 수정
				5. 결함 조치 보류
				6. 결함 종료
				7. 결함 해제
		7. 최종 결함 분석 및 보고서 작성
	- 결함 분류
		- 시스템 결함: 어플리케이션 환경, 데이터베이스 처리에서 발생된 결함
		- 기능 결함: 어플리케이션 기획, 설계 단계에서 유입된 결함
		- GUI 결함: 사용자 화면 설계에서 발생된 결함
		- 문서 결함: 사용자의 요구사항과 기능 요구사항의 불일치
	- 결함 심각도
		- High: 더이상 프로세스를 진행할 수 없도록 만드는 결함
		- Medium: 시스템 흐름에 영향을 미치는 결함
		- Low: 시스템 흐름에는 영향을 미치지 않는 결함
	- 결함 우선순위
		- 발견된 결함 처리에 대한 신속성 나타내는 척도
		- 심각도가 높다고 반드시 우선순위가 높은 것은 아님
	- 결함 관리 도구
		- ex) Mantis, Trac, Redmine, Bugzilla

6. 어플리케이션 성능 분석
	- 사용자가 요구한 기능을 최소한의 자원 사용해 최대한의 기능 신속히 처리하는 정도
	- 측정 지표
		- 처리량
		- 응답 시간
		- 경과 시간
		- 자원 사용률
	- 성능 테스트 도구
		- 성능 테스트하기 위해 어플리케이션에 부하나 스트레스 가함
		- ex) JMeter, LoadUI, OpenSTA
	- 시스템 모니터링 도구
		- 어플리케이션이 실행됐을 때 시스템 자원의 사용량 확인, 분석
		- ex) Scouter, Zabbix
	- 성능 저하 원인 분석
		- DB 연결 위한 Connection 객체 생성, 쿼리 실행 로직에서 자주 발생

7. 복잡도
	- 시스템 구성 요소 또는 소프트웨어의 복잡한 정도
	- 측정 방법
		- LOC: 원시 코드 라인 수 측정해 비용 산정
		- 시간 복잡도
			- 알고리즘을 수행하기 위해 프로세스가 수행하는 연산 횟수 수치화
			- 점근 표기법: 명령어의 실행 횟수 표기
				- 빅오 표기법: 실행시간 최악일 때 표기, 주로 사용
					- O(1): 스택 Push, Pop
					- O(logn): 이진 트리, 이진 검색
					- O(n): for문
					- O(nlogn): 힙 정렬, 합병 정렬
					- O(n^2): 삽입 정렬, 쉘 정렬, 선택 정렬, 버블 정렬, 퀵 정렬
					- O(2^n): 피보나치 수열
				- 빅세타 표기법: 실행시간 평균일 때 표기
				- 오메가 표기법: 실행시간 최상일 때 표기
		- 순환 복잡도
			- 순환 복잡도 = 제어 흐름도의 영역 수 = N(Edge) - N(Node) + 2

8. 어플리케이션 성능 개선
	- 소스코드 최적화
		- Clean Code
			- 단순 명료하게 잘 작성된 코드
			- 작성 원칙
				- 가독성, 단순성, 의존성 배제, 중복성 최소화, 추상화
		- Bad Code
			- 스파게티 코드: 코드 로직이 서로 복잡하게 얽혀 있는 코드
			- 외계인 코드: 오래되거나 참고문서가 없어 유지보수 작업이 어려운 코드
		- 유형
			- 클래스 분할 배치: 응집도 높이고 크기 작게 작성
			- 느슨한 결합: 추상화된 자료구조, 메소드 구현하여 클래스간 의존성 최소화
			- 코딩 형식 준수
			- 좋은 이름 사용
			- 적절한 주석 사용
	- 소스코드 품질 분석 도구
		- 정적 분석 도구
			- 작성한 코드 실행하지 않고 코딩 스타일, 복잡도 분석
			- ex) pmd, cppcheck, SonarQube, checkstyle, ccm, cobertura
		- 동적 분석 도구
			- 작성한 코드 실행해 메모리 누수, 스레드 결함 분석
			- ex) Avalanche, Valgrind










