# Software Development

## Contents  
[**1. 데이터 입출력 구현**](#1-데이터-입출력-구현)  
[**2. 통합 구현**](#2-통합-구현)  
[**3. 제품 소프트웨어 패키징**](#3-제품-소프트웨어-패키징)  
[**4. 어플리케이션 테스트 관리**](#4-어플리케이션-테스트-관리)  
[**5. 인터페이스 구현**](#5-인터페이스-구현)  

----

## 1. 데이터 입출력 구현
1. 자료구조
	- 프로그램에서 사용하기 위한 자료를 저장하는 방법, 자료간의 관계 및 처리방법 연구분석
	- 종류
		- 선형 리스트 (Linear List)
			- 일정한 순서에 의해 나열된 자료 구조
			- 종류
				- 연속 리스트 (Contiguous List)
					- 연속된 기억장소에 저장되는 자료구조(배열)
					- 기억장소 이용효율 밀도 1 (좋음)
				- 연결 리스트 (Linked List)
					- 노드의 포인터 이용해 순서에 따라 서로 연결시킨 자료구조
					- 연속적으로 놓여있지 않아도 저장 가능
					- 노드 삽입 및 삭제 작업 용이
					- 기억 공간의 이용 효율 안 좋음, 접근 속도 느림
		- 스택 (Stack)
			- LIFO 방식의 자료구조
			- Overflow: 공간이 모두 채워져 있는 상태에서 데이터 삽입
			- Underflow: 더 이상 삭제할 데이터가 없는 상테에서 데이터 삭제
		- 큐 (Queue)
			- FIFO 방식의 자료구조
			- 포인터 구성
				- Front Pointer: 가장 먼저 삽입된 자료의 기억 공간 가리킴
				- Rear Pointer: 가장 마지막에 삽입된 자료의 기억 공간 가리킴
		- 그래프 (Graph)
			- 정점(Vertex)과 간선(Edge)로 구성된 자료구조
			- 방향성 유무에 따라 방향 그래프, 무방향 그래프로 구분
			- 트리(Tree)
				- 정점(Node)과 선분(Branch)을 이용해 사이클 이루지 않도록 구성한 그래프
				- 용어
					- Node: 하나의 기억 공간
					- Root Node: 트리의 맨 위에 있는 노드
					- Degree(차수): 각 노드에서 뻗어나온 가지의 수
					- Terminal Node(= Leaf Node): 자식이 없는 노드
					- Son Node: 어떤 노드에 연결된 다음 레벨의 노드
					- Parent Node: 어떤 노드에 연결된 이전 레벨의 노드
					- Brother Node(= Sibling): 동일한 부모를 갖는 노드들
					- 트리의 차수: 차수들 중 가장 많은 수
				- 운행법 (Traversal)
					- 트리를 구성하는 각 노드들을 찾아가는 방법
					- Preorder: Root -> Left -> Right
					- Inorder: Left -> Root -> Right
					- Postorder: Left -> Right -> Root

2. 정렬
	- 삽입 정렬 (Insertion Sort, O(n^2))
		- 모든 원소를 앞에서부터 정렬된 부분과 비교해 자신의 위치에 맞는 곳에 삽입  
		![image](https://user-images.githubusercontent.com/53277342/154679777-087513d1-aa63-4bce-8c25-03aebd2a5379.png)
		![image](https://user-images.githubusercontent.com/53277342/154679792-a137372a-169d-4a61-a89e-bbbf45344b33.png)
	- 셸 정렬 (Shell Sort, 평균 O(n^1.5), 최악 O(n^2))
		- 특정 매개변수 값의 길이를 갖는 부분 리스트 여러 개 생성 후 삽입 정렬  
		![image](https://user-images.githubusercontent.com/53277342/154680229-cf7b7c39-8923-43c0-a6c2-994eca1fbd70.png)
	- 선택 정렬 (Selection Sort, O(n^2))
		- 모든 원소 중 최소값을 찾아 맨 앞에 있는 값과 교체  
		![image](https://user-images.githubusercontent.com/53277342/154680874-de35524e-b172-42da-88d1-227f547a41ee.png)
	- 버블 정렬 (Bubble Sort, O(n^2))
		- 인접한 두 원소를 비교해 교차하면서 정렬  
		![image](https://user-images.githubusercontent.com/53277342/154681177-086e47f5-09b8-4576-8f2b-8fd253d8cbba.png)
	- 퀵 정렬 (Quick Sort, 평균 O(nlogn), 최악 O(n^2))
		- Pivot 기준으로 부분 리스트로 분할 후 정렬  
		![image](https://user-images.githubusercontent.com/53277342/154682153-c8ba59f4-a442-4386-895a-83336b783c80.png)
	- 힙 정렬 (Heap Sort, O(nlogn))
		- 전이진 트리(Complete Binary Tree)에서 자식 노드와 부모 노드 비교해 정렬  
		![image](https://user-images.githubusercontent.com/53277342/154683949-a7aa3caa-771c-44d2-8077-1bb728135c81.png)
	- 합병 정렬 (Merge Sort, O(nlogn))
		- 이미 정렬되어있는 두 개의 리스트를 하나로 합병 후 정렬  
		![image](https://user-images.githubusercontent.com/53277342/154684156-c3c69835-07c0-46b0-bf51-59faba607c5e.png)
	- 기수 정렬 (Radix Sort, O(dn))
		- 자릿수별로 정렬  
		![image](https://user-images.githubusercontent.com/53277342/154685160-29bf5d15-efd3-4947-b418-caf6d725d86c.png)

3. 데이터베이스
	- 업무를 수행하는데 필요한 데이터들의 모임
	- 특징
		- 통합된 데이터 (Integrated Data): 중복을 배제한 데이터의 모임
		- 저장된 데이터 (Stored Data): 저장매체에 저장된 자료
		- 운영 데이터 (Operational Data): 존재 가치가 확실하고 없어서는 안 되는 자료
		- 공용 데이터 (Shared Data): 여러 응용 시스템들이 공동 소유 및 유지
	- DBMS (DataBase Management System, 데이터베이스 관리 시스템)
		- 사용자와 DB 사이에서 사용자의 요구에 따라 정보 생성 및 DB 관리해주는 소프트웨어
		- 데이터 종속성, 중복성 배제
		- 기능
			- 정의 (Definition)
				- DB에 저장될 데이터의 타입, 구조 정의, 이용 방식, 제약 조건 명시
			- 조작 (Manipulation)
				- 데이터 검색, 갱신, 삽입, 삭제하기 위한 인터페이스 수단 제공
			- 제어 (Control)
				- 데이터 무결성 유지되도록 제어
				- 허가된 데이터만 접근할 수 있도록 권한 검사
				- 여러 사용자가 동시 접근할 때 정확성 유지하도록 병행 제어 (Concurrency Control)
	- 스키마 (Schema)
		- DB 구조와 제약 조건에 관한 명세를 기술한 메타데이터의 집합
		- 사용자의 관점에 따른 분류
			- 외부 스키마: 각 개인의 입장에서 DB의 논리적 구조
			- 개념 스키마: 모든 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 DB 논리적 구조, 하나만 존재
			- 내부 스키마: 물리적 저장장치 입장의 DB 구조, 형식 및 표현방법, 물리적 순서 나타냄

4. 절차형 SQL
	- 연속적인 실행이나 제어가 가능한 SQL
	- 저장 모듈 생성 가능, 입출력 패킷 적은 편, 기능별 모듈화 가능
	- 종류
		- 프로시져 (Procedure): 호출을 통해 미리 저장해놓은 SQL 작업 수행
		- 트리거 (Trigger): 이벤트 발생할 때마다 관련 작업 자동 수행
		- 사용자 정의 함수: 일련의 작업 연속 처리, 처리 결과 단일값 반환
	- 쿼리 성능 최적화
		- 데이터 입출력 어플리케이션 성능 향상 위해 SQL 코드 최적화
		- APM 사용해 최적화할 쿼리 선정
			- APM: SQL이 효율적으로 수행되도록 최적의 경로 찾아주는 모듈

## 2. 통합 구현
1. 단위 모듈 테스트
	- 프로그램의 단위 기능 모듈이 정해진 기능 정확히 수행하는지 검증
	- 기법
		- 화이트박스 테스트
			- 모듈의 소스코드 오픈시킨 상태에서 모든 논리적인 경로 테스트
		- 블랙박스 테스트
			- 특정 기능이 완전히 작동되는 것 입증하는 테스트
	- 테스트 케이스 구성 요소
		- 식별자, 테스트 항목, 입출력 명세, 환경 설정, 특수 절차 요구, 의존성 기술
	- 테스트 프로세스
		1. 계획 및 제어
		2. 분석 및 설계: 테스트 시나리오, 테스트 케이스 작성
			- 테스트 시나리오: 테스트 케이스들을 묶은 집합
		4. 구현 및 실현: 테스트 프로시저 명세
			- 테스트 프로시저: 테스트 케이스의 실행 순서, 테스트 스크립트
		5. 평가
		6. 완료

2. 개발 지원 도구
	- IDE (Integrated Development Environment, 통합 개발 환경)
		- 편집기(Editor), 컴파일러(Compiler), 디버거(Debugger)를 하나의 인터페이스로 통합
	- 빌드 도구
		- 소스 코드 파일들을 컴퓨터에서 실행할 수 있는 소프트웨어로 변환하는 소프트웨어
		- 전처리, 컴파일 등의 작업 수행
		- ex) Ant, Maven, Gradle

## 3. 제품 소프트웨어 패키징
1. 소프트웨어 패키징
	- 모듈별로 생성한 실행 파일들 묶어 배포용 설치 파일 만드는 것
	- 사용자 중심 진행, 모듈화하여 패키징
	- 작업 순서
		1. 기능 식별: 코드 기능 확인
		2. 모듈화: 기능단위 코드 ㄷ분류
		3. 빌드 진행: 모듈단위 실행파일 생성
		4. 사용자 환경 분석: 최소 운영환경 정의
		5. 패키징 및 적용 시험: 패키징, 테스팅, 사용자 입장에서 불편사항 확인
		6. 패키징 변경 개선: 불편사항 반영 패키징 개선
		7. 배포

2. 디지털 저작권 관리 (DRM, Digital Right Management)
	- 저작권: 창작자가 가지는 배타적 독점적 권리
	- DRM: 저작권자가 의도한 용도로만 사용되도록 하는 디지털 컨텐츠 관리 및 보호 기술  
	![image](https://user-images.githubusercontent.com/53277342/154802081-4e2dfc77-a4ab-486a-84ca-c2ce40460403.png)
	- 구성 요소
		- 클리어링 하우스: 저작권 관리를 수행하는 곳
		- 컨텐츠 제공자: 컨텐츠 제공하는 저작권자
		- 패키저: 컨텐츠와 메타 데이터를 배포 가능한 형태로 묶어 암호화하는 프로그램
		- 컨텐츠 분배자: 암호화된 컨텐츠를 유통하는 곳
		- 컨텐츠 소비자: 컨텐츠 구매해서 사용하는 주체
		- DRM 컨트롤러: 배포된 컨텐츠의 이용 권한 통제하는 프로그램
		- 보안 컨테이너: 컨텐츠 원본을 안전하게 유통하기 위한 전자적 보안장치
	- 기술 요소
		- 암호화: 컨텐츠 및 라이선스 암호화
		- 키 관리: 암호화한 키 저장 및 분배 기술
		- 암호화 파일 생성: 암호화된 컨텐츠로 생성하기 위한 기술
		- 식별 기술: 컨텐츠에 대한 식별 체계 표현 기술
		- 저작권 표현: 라이선스 내용 표현 기술
		- 정책 관리: 라이선스에 대한 정책 표현 및 관리 기술
		- 크랙 방지: 크랙에 의한 컨텐츠 사용 방지 기술
		- 인증: 라이선스 사용 기준이 되는 사용자 인증 기술

3. 소프트웨어 설치 메뉴얼
	- 사용자가 소프트웨어를 설치하는 과정에 필요한 내용 기록한 설명서
	- 구성
		1. 목차 및 개요
		2. 서문
			- 문서 이력, 설치 메뉴얼의 주석, 설치 도구의 구성, 설치 환경 체크 항목
		3. 기본 사항
			- 개요, 설치 관련 파일, 설치 아이콘, 프로그램 삭제, 관련 추가 정보

4. 소프트웨어 사용자 메뉴얼
	- 사용자가 소프트웨어를 사용하는 과정에서 필요한 내용 기록한 설명서
	- 구성
		1. 목차 및 개요
		2. 서문
			- 문서 이력, 사용자 메뉴얼의 주석, 기록 보관 내용
		3. 기본 사항
			- 개요, 사용 환경, 관리, 버전별 특징, 인터페이스 특징, 구동 환경

5. 소프트웨어 버전 등록
	- 형상관리 (SCM, Software Configuration Management)
		- 소프트웨어의 변경사항 관리하기 위한 활동
		- 가시성, 추적성 보장으로 생산성, 품질 증대
		- 기능
			- 형상 식별: 형상 관리 대상에 관리 번호 부여해 수정 및 추적 용이
			- 버전 제어: 생성된 다른 버전의 형상 항목 관리
			- 형상 통제 (변경 관리): 변경 요구 검토
			- 형상 감사: 무결성 평가 후 공식적으로 승인
			- 형상 기록 (상태 보고): 형상 기록, 관리
		- 버전 등록 용어
			- Repository: 정보들이 저장되어 있는 곳
			- Import: 아무것도 없는 저장소에 처음으로 파일 복사
			- Check-Out: 프로그램 수정 위해 저장소에서 파일 받아옴
			- Check-In: 체크아웃한 파일 수정 완료 후 새로운 버전으로 갱신
			- Commit: 체크인 수행할 때 Conflict 확인, 수정 후 갱신 완료
			- Update: 저장소에 있는 최신 버전으로 동기화
		- 버전 등록 과정
			1. Import
			2. Check-Out
			3. Commit
			4. Update
			5. Diff

6. 소프트웨어 버전 관리 도구
	- 공유 폴더 방식
		- 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리
	- 클라이언트/서버 방식
		- 버전 관리 자료가 서버에 저장되어 관리
	- 분산 저장소 방식
		- 버전 관리 자료가 하나의 원격 저장소와 분산된 개발자의 로컬 저장소에 저장되어 관리
	- Subversion (SVN)
		- 서버의 자료를 클라이언트로 복사해 작업한 후 변경내용 서버에 반영
	- Git
		- 분산 버전 관리 시스템
		- 주요 용어
			- 지역 저장소: 개발자들이 실제 개발을 진행하는 장소
			- 원격 저장소: 협업을 위해 버전을 공동 관리하는 곳
			- Staging Area: 작업 내용을 한번 더 확인하여 안정된 버전 관리 위한 장소
			- add: 작업 내역 지역 저장소에 저장하기 위해 Staging Area에 추가
			- commit: 작업 내역 지역 저장소에 저장
			- branch: 독립적으로 동시에 작업 진행 가능하며 마무리되면 Master Branch에 병합
			- checkout: 지정한 브랜치로 이동
			- merge: 지정한 브랜치의 변경 내역을 HEAD 포인터가 가리키는 브랜치에 병합
			- init: 지역 저장소 생성
			- remote add: 원격 저장소 연결
			- push: 로컬 저장소 변경 내역을 원격 저장소에 반영
			- fetch: 원격 저장소의 변경 이력을 지역 저장소로 가져와 반영
			- clone: 원격 저장소의 전체 내용을 지역 저장소로 복제
			- fork: 지정한 원격 저장소의 내용을 자신의 원격 저장소로 복제

7. 빌드 자동화 도구
	- 빌드: 소스코드 컴파일 후 여러 모듈 묶어 실행 파일로 만드는 과정
	- 빌드 자동화 도구: 빌드, 테스트, 배포 자동화 도구
	- CI (Contiunous Integration, 지속적인 통합)
		- Agile 환경에서 작업 마무리 될 때마다 모듈 단위로 나눴던 코드들 지속적으로 통합
	- 예시
		- Jenkins
			- Java 기반 오픈소스, 가장 많이 이용, Web GUI 제공
			- 분산 빌드 및 테스트 가능






